export const metadata = {
  subject: 'The "Only" Pattern you need in Frontend Architecture',
  browserURl: 'https://cesalberca.com/newsletter/2025-10-13_the-use-case-pattern',
  description: `If I had to choose only one pattern to implement as a Frontend Architect it would be the **use case pattern**. I've implemented this pattern countless times in projects **ranging from Startups** to **Multi Million and international companies**. I've perfected over a _decade_ how I implement this pattern and in this newsletter I want to show _you_.`
}

If I had to choose only one pattern to implement as a Frontend Architect it would be the **use case pattern**. I've implemented this pattern countless times in projects **ranging from Startups** to **Multi Million and international companies**. I've perfected over a _decade_ how I implement this pattern and in this newsletter I want to show _you_.

This pattern is nothing sort of new, it has been around longer than I've been alive, however the way I apply in the Frontend is something that I haven't seen (_yet_). The Use Case pattern allows you to separate your business logic in such a way that you can add different pieces of code to completely change the way your code runs in an easy and transversal way.

> The Use Case Pattern allows you to orchestrate your business logic and configure how your application runs

## What is an Use Case?

**A Use Case represents how a user interacts with the system**. Everything a user can do, well, that's a use case. When coding a use case the idea is to encapsulate a complete set of actions, so that the use cases can be reused. Use cases orchestrate, **they know who to call** and integrate the different pieces together so we return to the UI what it needs. Let's see some code so you can get a better understanding.

## `UseCase` Interface

Everything starts with the `UseCase` interface:

```typescript
export interface UseCase<In, Out> {
  handle(input?: In): Promise<Out>
}
```

An UseCase is a class (it can be a function too, but I prefer classes) that has a method called `handle()`. This method, receives an input typed as `In` and return an output typed as `Out`.

As you might have noticed, the output returned is **always a Promise**. This is a conscious design choice given that most of the time in the Frontend our use cases are going to indirectly make API calls, which happen to be asynchronous.

> If you need to execute a computation-heavy use case, using Promises means you can avoid blocking the main thread.

## The `UseCase`

Now we can implement the UseCase.

```typescript
export class GetDestinationsQry implements UseCase<void, Destination[]> {
  constructor(
    private readonly destinationRepository: DestinationRepository,
    private readonly destinationOrderer: DestinationOrderer,
  ) {}

  async handle(): Promise<Destination[]> {
    return this.destinationOrderer.order(await this.destinationRepository.findAll())
  }
}
```

Here we are using two classes:

1. `DestinationRepository`: Makes an API Request using the Repository Pattern (which I'll talk about in another newsletter)
2. `DestinationOrderer`: Orders the Destination using a Domain class

Now, you ar probably asking yourself why would I add this complexity to my code? I could just in the UI call the API using `fetch` and order the `Destinations` in the component. Well, for starters, as you can see in this code, there's no UI code, which means I can in the future change UI frameworks or call this Use Case from different places without needing to change a _lot_ of code. This has something to do with how I apply Software Architecture Layers and Domain Driven Design, which I'll explain in another issue of this Newsletter.

And I can't get the benefits of abstracting how I execute the use cases to handle transversal functionality.

## The `UseCaseService`

The trick is how to execute the UseCase. One would think you directly create the instance and execute them as follows, from let's say your React Component:

```tsx
import { type FC } from 'react'

const getDestinationsQry = new GetDestinationsQry(destinationRepository, destinationOrderer)

export const Comp: FC = () => {
  return <button onClick={() => getDestinationsQry.handle()}>Click me</button>
}
```

However, we are missing a great opportunity. What if we want to support the following features:

1. Error handling
2. Logging
3. Cache
4. And many more!

The way to do that is by creating the `UseCaseService`, which helps us abstract _how_ an use case is executed.
